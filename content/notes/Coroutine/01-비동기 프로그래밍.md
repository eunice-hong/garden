---
title: "비동기 프로그래밍"
date: 2021-11-28 16:46:00 +0900
draft: true
---

쓰레드 (Threading)

콜백 (Callbacks)

Future, Promises ...

리액티브 (Reactive Extension (Rx))

⭐️Coroutines⭐️

  

# 쓰레드 (Threading)

**단점**

- [No Cheap] 쓰레드 Context switching은 자원이 많이 쓰인다.
- [No Infinite] OS에 따라 실행가능한 쓰레드의 개수가 정해져있다. SSA라면, 병목현상의 주 원인이 될 것이다.
- [No Always] JavaScript의 경우 쓰레드를 지원하지 않는다.
- [No Easy] 멀티 쓰레드 프로그래밍에서 풀기 어려운 문제들이 있다. (Ex. 디버깅, Race condition 피하기 등)

  

# 콜백 (Callbacks)

**단점**

- 중첩 콜백으로 인한 복잡성 증가.
    
    하나의 함수가 콜백으로 쓰이기 시작하면, 이 함수 또한 콜백을 필요로하는 상황이 생긴다. 이렇게 되면, 콜백이 끊임없이 중첩되어, 코드가 난해해진다. → Christmas tree 문제, or Callback Hell
    
- 에러 처리가 복잡해진다. 중첩 관계는 에러를 처리하고 전달하기 힘들게 만든다.

  

콜백 방식은 JS 같은 이벤트 루프 아키텍쳐에서 많이 사용된다. 하지만, 이러한 언어들도 위와 같은 문제들 때문에 아래의 방식들을 더 선호한다.

  

# Future, Promises ...

**단점**

- 기존 프로그래밍 방식과 다르다. 위의 콜백 방식처럼, function call이 연결되어있는 방식을 사용한다. 기존에 많이 쓰이는 loop, exception handling 등의 구조를 사용할 수 없다.
- API 마다 객체가 달라, 통합하여 사용할 수 없다.
- 특정 반환값 밖에 줄 수 없다. 실제 필요한 결과값이 아니라 Promise를 반환한다.
- 에러 처리가 어렵다. 에러를 전달하기 어렵다.

  

  

# 리액티브 (Reactive Extension (Rx))

  

  

  

# ⭐️Coroutines⭐️

  

- The function signature remains exactly the same. The only difference is `suspend` being added to it. The return type however is the type we want to be returned.
- The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called `launch` which essentially kicks-off the coroutine (covered in other tutorials).
- The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs
- It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.

# reference
- https://kotlinlang.org/docs/coroutines-guide.html#additional-references