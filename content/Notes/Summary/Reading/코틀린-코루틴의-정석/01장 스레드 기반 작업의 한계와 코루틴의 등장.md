---
title: 01장 스레드 기반 작업의 한계와 코루틴의 등장
description: "JVM 프로세스와 스레드에 대한 이해 및 기존 멀티 스레드 프로그래밍의 한계와 코루틴이 이를 극복한 방법"
date: 2024-08-04 10:00:00 +0900
draft: true
noindex: false
tags: ["Kotlin", "Coroutine"]
---

### 1. 주요 개념 정리
> 1. 핵심 용어와 개념: 각 챕터에서 다루는 주요 용어와 개념을 간단히 요약합니다.
> 2. 개념 간의 관계: 개념들이 서로 어떻게 연결되는지 설명합니다.


1. JVM 이란 무엇인지에 대한 간단한 소개를 외워야한다.
    1. Java Virtual Machine 의 약자로, 어떤 OS에서도 Java 기반의 고급 언어로 작성된 프로그램을 실행 할 수 있게 도와주는 미들웨어다.
    2. Java 기반의 언어에 우리가 이번 책에서 다룰 Kotlin 이 포함된다.
    3. JVM 을 사용하여 Kotlin 으로 Android 기기에서 실행되는 어플리케이션이나 백엔드 서버를 구축 할 수 있다.
2. JVM에서 스레드 생성 및 관리 방법, 메모리 구조와 스레드의 관계
    1. JVM 은 각 프로그램의 main 함수를 기준으로 실행되는데, 이것이 메인 스레드로 취급한다.(Fun main(){})
    2. 함수가 시작되고 종료되기 까지 처리되는 작업은 오로지 하나의 스레드에 할당되어 처리된다.
    3. 메모리 구조와 스레드의 관계???
3. 단일 스레드 애플리케이션의 한계
    1. 단일 스레드 애플리케이션의 한계가 있습니다.
    2. DB에서 값을 읽어와 화면에 표시하는 애플리케이션 기능을 예로 떠올려보자.
    3. (차트 이미지 필요)
    4. 애플리케이션이 시작되고 DB 에서 값을 읽어오기까지 약 300ms 가 걸린다고 가정했을 때,
    5. 애플리케이션에 할당된 스레드는 하나이기에, 값을 불러오는 작업을 진행하는 동안 화면을 갱신하는 일은 할 수 없다. 불러온 값을 화면에 보여주는 작업은 최소 300ms동안 화면이 변경되지 않는 상태를 기다린 후에 실행 할 수 있다.
    6. 애플리케이션이 다양한 작업을 처리하는 동안 화면을 사용할 수 없다면, 사용자는 몹시 불편하다.
    7. 이를 해소하기 위해 다양한 방법을 사용한다.
4. 멀티 스레드 프로그래밍
    1. Thread 클래스 사용한 멀티 스레드 프로그래밍
        1. Thread class 를 사용하여 별도의 쓰레드를 생성하는 방식이다.
        2. 한계
            1. Class 실행 및 종료를 개발자가 모두 관리해야한다. Memory leak 등의 문제를 일으킬 수 있다.
            2. 작업 요청을 각 스레드에서 처리해야하니 비용이 크다.
            3. 스레드 클래스로 만든 작업 처리방식과 메인 스레드의 차이?
    2. Executor를 통해 스레드 풀을 사용한 멀티 스레드 프로그래밍
        1.
    3. 그 외 방식
        1. 함수 체이닝(콜백 방식)를 사용하여, 작업 간 연결관계를 명시한다.
        2. Reactive X 를 사용하여, 값의 변화에 따라 작업이 수행되는 순서를 정한다.
        3. 함수 체이닝, Reactive X 보다 코루틴이 나은 점은?
5. 코루틴의 스레드
    1. 코루틴이란?
        1. 경량 스레드라고도 불린다.
        2. 코루틴의 정의
    2. 코루틴이 스레드 블로킹 문제를 해결하는 방법
        1. 호출되는 순서대로 각기 알맞은 스레드에 할당되어 실행된다. 코루틴 작업 처리가 일시정지되면, 재개 준비가 완료되기 전까지 다른 코루틴에게 스레드를 양도한다는 특징이 있다.


- 스레드: 프로그램 작업 단위
- Reactive X <-> Coroutine 호환 방법 알아보기
- Reactive X <-> Coroutine 비교하기
- [코루틴 기초])(https://medium.com/@sunminlee89/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-coroutine-%EA%B8%B0%EC%B4%88-1342ae6916ce)
- Anti corruption layer

- JVM (Java Virtual Machine)의 소개, 역할, 중요성
- JVM에서 스레드 생성 및 관리 방법

### 2. [코드 예제 분석][repository]
1. 챕터 내 예제 코드 분석: 책에서 제공된 코드 예제를 직접 실행해보고, 코루틴이 실제로 어떻게 작동하는지 설명합니다.
2. 추가 예제: 가능하다면 책의 내용을 바탕으로 추가적인 예제를 만들어보는 것도 좋습니다. 이를 통해 내용을 더 깊이 이해하고 다른 멤버들에게 설명할 수 있습니다.
### 3. 실전 응용
1. 실제 사용 사례: 실전에서 어떻게 사용될 수 있는지 사례를 소개합니다.
2. 장단점 및 한계: 실전에서 사용할 때의 장점과 단점을 정리하고, 어떤 상황에서 주의가 필요한지 논의합니다.
### 4. 질의 응답
> 1. 예상 질문 준비: 발표 내용을 기반으로 예상될 수 있는 질문을 미리 생각해보고 답변을 준비합니다. 질문을 받는 연습을 통해 발표 후 Q&A 세션에 대비합니다.
> 2. 스터디 멤버와 토론: 발표 후에는 스터디 멤버들과 자유롭게 토론을 유도합니다. 멤버들의 이해도를 높이고 다양한 시각을 공유할 수 있습니다.

#### 4.1. Q&A 및 퀴즈

> [!Check]- 내용 정리하기
>
> ### 퀴즈 1: JVM상에서 실행되는 코틀린 애플리케이션은 실행 시 어떤 스레드를 생성하나요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 메인 스레드를 생성합니다!
> > 그 이유는 코틀린 애플리케이션은 실행 시 메인 스레드를 생성하고 이를 사용해 코드를 실행하기 때문입니다.
>
> ### 퀴즈 2: 단일 스레드 애플리케이션의 주요 한계는 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 응답성이 떨어질 수 있습니다!
> > 그 이유는 단일 스레드 애플리케이션은 한 번에 하나의 작업만 수행할 수 있기 때문입니다.
>
> ### 퀴즈 3: 멀티 스레드 프로그래밍의 주요 장점은 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 여러 작업을 동시에 실행할 수 있습니다!
> > 그 이유는 멀티 스레드 프로그래밍을 사용하면 단일 스레드 프로그래밍의 문제를 해결할 수 있기 때문입니다.
>
> ### 퀴즈 4: Thread 클래스를 직접 상속해 스레드를 생성할 때의 주요 단점은 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 스레드의 재사용이 어렵습니다!
> > 그 이유는 생성된 스레드의 재사용이 어려워 리소스의 낭비를 일으키기 때문입니다.
>
> ### 퀴즈 5: Executor 프레임웍의 주요 기능은 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 스레드풀을 사용해 스레드의 생성과 관리를 최적화합니다!
> > 그 이유는 스레드풀을 통해 스레드 재사용을 용이하게 하기 때문입니다.
>
> ### 퀴즈 6: 기존의 멀티 스레드 프로그래밍 방식들이 근본적으로 해결하지 못한 문제는 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 스레드 블로킹 문제입니다!
> > 그 이유는 기존 방식들은 스레드 블로킹 문제를 근본적으로 해결하지 못하기 때문입니다.
>
> ### 퀴즈 7: 스레드 블로킹이란 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 스레드가 작업을 기다리면서 리소스를 소비하지만 아무 일도 하지 않는 상태입니다!
> > 그 이유는 스레드 블로킹이란 스레드가 작업을 기다리는 동안 리소스를 소비하는 상태를 말하기 때문입니다.
>
> ### 퀴즈 8: 코루틴이 스레드 블로킹 문제를 어떻게 해결하나요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 필요할 때 스레드 사용 권한을 양보하고 일시 중단합니다!
> > 그 이유는 코루틴은 다른 작업이 스레드를 사용할 수 있게 하여 스레드 블로킹 문제를 해결하기 때문입니다.
>
> ### 퀴즈 9: 일시 중단 후 재개된 코루틴은 어떻게 실행되나요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 재개 시점에 사용할 수 있는 스레드에 할당돼 실행됩니다!
> > 그 이유는 일시 중단 후 재개된 코루틴은 재개 시점의 사용 가능한 스레드에 할당되기 때문입니다.
>
> ### 퀴즈 10: 코루틴의 주요 장점은 무엇인가요?
>
> > [!Answer]- 정답 확인하기
> > 정답은 생성과 전환 비용이 적고, 스레드에 자유롭게 붙였다 뗐다 할 수 있습니다!
> > 그 이유는 코루틴은 경량 스레드로서 스레드 블로킹 없이 비동기적으로 작업을 처리할 수 있기 때문입니다.

### 5. 참고 자료
1. 참고 자료: 추가로 참고할 수 있는 자료나 문서를 준비한다.

## 3. 참고 자료

1. [코틀린 코루틴의 정석][book]: 책에 대한 정보를 확인할 수 있습니다.
2. [코틀린 코루틴의 정석/코드 저장소][repository]: 책의 예제 코드를 확인할 수 있습니다.


# 1.1. JVM 프로세스와 스레드

## 1.1.1. JVM 프로세스 개요

<!--
- 내용 요약: JVM (Java Virtual Machine)의 소개, 역할, 중요성
- 시각 자료: JVM 구조 다이어그램
- 핵심 메시지: JVM의 핵심 역할과 필요성
- 질의응답 준비: JVM의 다른 역할과 특징에 대한 질문 대비
-->

> JVM (Java Virtual Machine)의 소개, 역할, 중요성



## 1.1.2. JVM에서의 스레드 관리

> JVM에서 스레드 생성 및 관리 방법


<!--
- 내용 요약: JVM에서 스레드 생성 및 관리 방법, 메모리 구조와 스레드의 관계
- 시각 자료: JVM 스레드 상태 변화 그림
- 핵심 메시지: JVM에서의 스레드 관리 방식 이해
- 질의응답 준비: 스레드 관리의 구체적인 예와 문제점 대비
-->


# 1.2. 단일 스레드의 한계와 멀티 스레드 프로그래밍

## 1.2.1. 단일 스레드 애플리케이션의 한계


<!--
- 내용 요약: 단일 스레드의 작동 방식, 주요 한계 (응답성 저하, 동시성 문제)
- 시각 자료: 단일 스레드의 작동 방식과 문제점을 보여주는 예제 코드
- 핵심 메시지: 단일 스레드의 제한 이해
- 질의응답 준비: 단일 스레드 환경에서의 문제 해결 방법 대비
-->

## 1.2.2: 멀티 스레드 프로그래밍을 통한 단일 스레드의 한계 극복

<!--
- 내용 요약: 멀티 스레드의 개념과 장점, 동시성 문제 해결 방법
- 시각 자료: 멀티 스레드 프로그래밍 예제 코드
- 핵심 메시지: 멀티 스레드 프로그래밍의 중요성
- 질의응답 준비: 멀티 스레드의 성능 향상 사례 대비
-->

# 1.3. 스레드, 스레드풀을 사용한 멀티 스레드 프로그래밍

## 1.3.1: Thread 클래스를 사용하는 방법과 한계

<!--
- 내용 요약: Thread 클래스를 사용한 스레드 생성 방법과 한계
- 시각 자료: Thread 클래스 사용 예제 코드
- 핵심 메시지: 직접 스레드 생성의 한계
- 질의응답 준비: Thread 클래스를 사용할 때의 문제점 대비
-->

## 1.3.2: Executor 프레임웍을 통해 스레드풀 사용하기

<!--
- 내용 요약: Executor 프레임워크 소개, 스레드풀의 개념과 장점
- 시각 자료: Executor 프레임워크 사용 예제 코드, 스레드풀의 장점 시각화
- 핵심 메시지: 스레드풀의 효율성
- 질의응답 준비: Executor 프레임워크의 다양한 사용 예 대비
-->

## 1.3.3: 이후의 멀티 스레드 프로그래밍과 한계

<!--
- 내용 요약: 멀티 스레드 프로그래밍의 발전, 남아있는 한계 (스레드 블로킹, 리소스 경쟁)
- 시각 자료: 스레드 블로킹 문제 설명 다이어그램
- 핵심 메시지: 멀티 스레드의 남아있는 문제점 이해
- 질의응답 준비: 블로킹 문제 해결 방안 대비
-->

# 1.4. 기존 멀티 스레드 프로그래밍의 한계와 코루틴

## 1.4.1: 기존 멀티 스레드 프로그래밍의 한계

<!--
- 내용 요약: 기존 멀티 스레드 프로그래밍의 문제점 (스레드 블로킹, 동기화 문제)
- 시각 자료: 멀티 스레드 문제점 사례 설명 그림
- 핵심 메시지: 기존 방식의 한계 이해
- 질의응답 준비: 멀티 스레드 환경에서의 문제 해결 방안 대비
-->

기존 스레드 방식과 `Executor` 를 사용한 방식 모두 스레드 블로킹 문제를 해결하지 못합니다. 



## 1.4.2: 코루틴은 스레드 블로킹 문제를 어떻게 극복하는가?

<!--
- 내용 요약: 코루틴의 개념과 장점, 비동기 프로그래밍, 코루틴의 작동 원리
- 시각 자료: 코루틴 작동 원리 다이어그램, 코루틴 사용 예제 코드
- 핵심 메시지: 코루틴의 효율성과 활용 방법
- 질의응답 준비: 코루틴의 성능 개선 사례 대비
-->


코루틴은 '경량 스레드' 라고도 불립니다. 그러나 정확히는 스레드와는 다르죠.

여러 코루틴을  병렬적으로 처리하는 경우를 예로 들어 설명해보겠습니다.

```markdown
1. 작업 A 는 main 스레드가 시작 직후 실행되는 작업입니다. 그리고 작업 중 일정 시간 동안 대기합니다. 
2. 작업 B 는 작업 A가 실행되는 도중에 호출되는 작업입니다.
3. 작업 C 는 작업 A, B 와 관계없이 실행되는 작업입니다.
```

위 조건에서 A, B, C 가 순차적으로 실행된다면, 실행 순서 아래와 같이 나타납니다.

<!-- TODO: 차트 이미지 추가 -->

일반 스레드에 할당된 작업 A가 잠시 멈춰있는 동안 스레드는 블로킹 상태가 됩니다. 
하지만, 코루틴으로 등록된 작업 A가 잠시 멈춰진 상태에서 스레드는 반환되어 작업 C를 실행하는데에 사용할 수 있습니다.
그리고 작업 C 실행이 끝나고, 작업 A 가 다시 실행할 준비가 되면, 해당 스레드에서 다시 실행됩니다.

이러한 방식으로 코루틴은 스레드 블로킹 문제를 해결합니다. 

